// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Os = require("os");
var Curry = require("bs-platform/lib/js/curry.js");
var Electron = require("electron");
var Caml_option = require("bs-platform/lib/js/caml_option.js");
var ElectronLog = require("electron-log");
var ElectronUpdater = require("electron-updater");
var IO$OptolithClient = require("../Data/IO.bs.js");
var Ipc$OptolithClient = require("./Ipc.bs.js");

function isUpdaterEnabled(param) {
  var match = Os.platform();
  if (match === "win32") {
    return Electron.app.isPackaged;
  } else {
    return false;
  }
}

function listenAndRun(mainWindow) {
  ElectronUpdater.autoUpdater.logger = ElectronLog;
  ElectronUpdater.autoUpdater.logger.transports.file.level = "info";
  ElectronUpdater.autoUpdater.autoDownload = false;
  var cancellationToken = {
    contents: undefined
  };
  if (isUpdaterEnabled(undefined)) {
    console.log("main: Updater is enabled, check for updates ...");
    ElectronUpdater.autoUpdater.on("update-available", (function (info) {
            Ipc$OptolithClient.FromMain.send(mainWindow, {
                  TAG: /* UpdateAvailable */3,
                  _0: info
                });
            ElectronUpdater.autoUpdater.removeAllListeners("update-not-available");
            
          }));
    Ipc$OptolithClient.FromRenderer.addListener(Electron.ipcMain, (function ($$event, param) {
            if (param) {
              Curry._2(IO$OptolithClient.Infix.$less$amp$great, ElectronUpdater.autoUpdater.checkForUpdates(), (function (res) {
                      var token = res.cancellationToken;
                      if (token !== undefined) {
                        cancellationToken.contents = Caml_option.some(Caml_option.valFromOption(token));
                        return Ipc$OptolithClient.FromRenderer.reply($$event, {
                                    TAG: /* UpdateAvailable */3,
                                    _0: res.updateInfo
                                  });
                      } else {
                        return Ipc$OptolithClient.FromRenderer.reply($$event, /* UpdateNotAvailable */0);
                      }
                    }));
            } else {
              ElectronUpdater.autoUpdater.downloadUpdate(cancellationToken.contents);
            }
            
          }));
    ElectronUpdater.autoUpdater.signals.progress(function (progressObj) {
          return Ipc$OptolithClient.FromMain.send(mainWindow, {
                      TAG: /* DownloadProgress */4,
                      _0: progressObj
                    });
        });
    ElectronUpdater.autoUpdater.on("error", (function (err) {
            return Ipc$OptolithClient.FromMain.send(mainWindow, {
                        TAG: /* AutoUpdaterError */5,
                        _0: err
                      });
          }));
    ElectronUpdater.autoUpdater.signals.updateDownloaded(function (param) {
          ElectronUpdater.autoUpdater.quitAndInstall();
          
        });
    Curry._2(IO$OptolithClient.Infix.$less$amp$great, ElectronUpdater.autoUpdater.checkForUpdates(), (function (res) {
            var token = res.cancellationToken;
            if (token !== undefined) {
              cancellationToken.contents = Caml_option.some(Caml_option.valFromOption(token));
              console.log("main: Update is available");
              return Ipc$OptolithClient.FromMain.send(mainWindow, {
                          TAG: /* UpdateAvailable */3,
                          _0: res.updateInfo
                        });
            } else {
              console.log("main: No update available");
              return ;
            }
          }));
  } else {
    console.log("main: Updater is not available");
  }
  
}

exports.isUpdaterEnabled = isUpdaterEnabled;
exports.listenAndRun = listenAndRun;
/* os Not a pure module */
