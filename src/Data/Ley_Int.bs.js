// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Caml_int32 = require("bs-platform/lib/js/caml_int32.js");
var Pervasives = require("bs-platform/lib/js/pervasives.js");
var Caml_format = require("bs-platform/lib/js/caml_format.js");

function compare(x, y) {
  if (x < y) {
    return /* LT */0;
  } else if (x > y) {
    return /* GT */2;
  } else {
    return /* EQ */1;
  }
}

function max(x, y) {
  if (x > y) {
    return x;
  } else {
    return y;
  }
}

function min(x, y) {
  if (x < y) {
    return x;
  } else {
    return y;
  }
}

function minmax(x, y) {
  if (x < y) {
    return [
            x,
            y
          ];
  } else {
    return [
            y,
            x
          ];
  }
}

function inc(x) {
  return x + 1 | 0;
}

function dec(x) {
  return x - 1 | 0;
}

function negate(x) {
  return -x | 0;
}

function abs(x) {
  if (x < 0) {
    return -x | 0;
  } else {
    return x;
  }
}

function even(x) {
  return x % 2 === 0;
}

function odd(x) {
  return x % 2 === 1;
}

function modUntilNoRemainder(_x, _div) {
  while(true) {
    var div = _div;
    var x = _x;
    var rem = Caml_int32.mod_(x, div);
    if (rem === 0) {
      return abs(div);
    }
    _div = rem;
    _x = div;
    continue ;
  };
}

function gcd(x, y) {
  if (x !== 0) {
    if (y === 0) {
      return x;
    }
    var match = minmax(x, y);
    return modUntilNoRemainder(match[0], match[1]);
  }
  if (y !== 0) {
    return y;
  }
  throw Pervasives.invalid_arg("gcd: Both inputs cannot be 0.");
}

function lcm(x, y) {
  if (x !== 0) {
    if (y !== 0) {
      return Caml_int32.div(Math.imul(x, y), gcd(x, y));
    } else {
      return 0;
    }
  }
  if (y !== 0) {
    return 0;
  }
  throw Pervasives.invalid_arg("lcm: Both inputs cannot be 0.");
}

function signum(x) {
  if (x < 0) {
    return -1;
  } else if (x > 0) {
    return 1;
  } else {
    return 0;
  }
}

function show(prim) {
  return prim.toString();
}

var unsafeRead = Caml_format.caml_int_of_string;

var readOption = Pervasives.int_of_string_opt;

exports.compare = compare;
exports.max = max;
exports.min = min;
exports.minmax = minmax;
exports.inc = inc;
exports.dec = dec;
exports.negate = negate;
exports.abs = abs;
exports.even = even;
exports.odd = odd;
exports.modUntilNoRemainder = modUntilNoRemainder;
exports.gcd = gcd;
exports.lcm = lcm;
exports.signum = signum;
exports.show = show;
exports.unsafeRead = unsafeRead;
exports.readOption = readOption;
/* No side effect */
