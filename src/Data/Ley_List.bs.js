// Generated by ReScript, PLEASE EDIT WITH CARE

import * as List from "bs-platform/lib/es6/list.js";
import * as $$Array from "bs-platform/lib/es6/array.js";
import * as Curry from "bs-platform/lib/es6/curry.js";
import * as Js_int from "bs-platform/lib/es6/js_int.js";
import * as $$String from "bs-platform/lib/es6/string.js";
import * as Caml_obj from "bs-platform/lib/es6/caml_obj.js";
import * as Pervasives from "bs-platform/lib/es6/pervasives.js";
import * as Caml_option from "bs-platform/lib/es6/caml_option.js";
import * as Ley_Int$OptolithClient from "./Ley_Int.bs.js";
import * as Ley_Ord$OptolithClient from "./Ley_Ord.bs.js";
import * as Ley_Monad$OptolithClient from "./Ley_Monad.bs.js";
import * as Ley_Tuple$OptolithClient from "./Ley_Tuple.bs.js";
import * as Ley_Option$OptolithClient from "./Ley_Option.bs.js";
import * as Ley_Functor$OptolithClient from "./Ley_Functor.bs.js";
import * as Ley_Foldable$OptolithClient from "./Ley_Foldable.bs.js";
import * as Ley_Function$OptolithClient from "./Ley_Function.bs.js";
import * as Ley_Applicative$OptolithClient from "./Ley_Applicative.bs.js";

function fmap(f, xs) {
  if (xs) {
    return {
            hd: Curry._1(f, xs.hd),
            tl: fmap(f, xs.tl)
          };
  } else {
    return /* [] */0;
  }
}

var include = Ley_Functor$OptolithClient.Make({
      fmap: fmap
    });

var fmap$1 = include.fmap;

function pure(x) {
  return {
          hd: x,
          tl: /* [] */0
        };
}

function ap(fs, xs) {
  if (!fs) {
    return /* [] */0;
  }
  if (!xs) {
    return /* [] */0;
  }
  var x = xs.hd;
  return Pervasives.$at(Curry._2(fmap$1, (function (f) {
                    return Curry._1(f, x);
                  }), fs), ap(fs, xs.tl));
}

var include$1 = Ley_Applicative$OptolithClient.Make({
      fmap: fmap$1,
      pure: pure,
      ap: ap
    });

var pure$1 = include$1.pure;

function alt(xs, ys) {
  if (xs) {
    return xs;
  } else {
    return ys;
  }
}

var include$2 = Ley_Applicative$OptolithClient.Alternative.Make({
      empty: /* [] */0,
      alt: alt
    });

function bind(f, xs) {
  if (xs) {
    return Pervasives.$at(Curry._1(f, xs.hd), bind(f, xs.tl));
  } else {
    return /* [] */0;
  }
}

var include$3 = Ley_Monad$OptolithClient.Make({
      pure: pure$1,
      fmap: fmap$1,
      bind: bind
    });

function foldr(f, initial, xs) {
  if (xs) {
    return Curry._2(f, xs.hd, foldr(f, initial, xs.tl));
  } else {
    return initial;
  }
}

function foldl(f, _initial, _xs) {
  while(true) {
    var xs = _xs;
    var initial = _initial;
    if (!xs) {
      return initial;
    }
    _xs = xs.tl;
    _initial = Curry._2(f, initial, xs.hd);
    continue ;
  };
}

var include$4 = Ley_Foldable$OptolithClient.Make({
      foldr: foldr,
      foldl: foldl
    });

var foldr$1 = include$4.foldr;

var foldl$1 = include$4.foldl;

var $$null = include$4.$$null;

var elem = include$4.elem;

var concatMap = include$4.concatMap;

var any = include$4.any;

var notElem = include$4.notElem;

var find = include$4.find;

function indexedAux(i, xs) {
  if (xs) {
    return {
            hd: [
              i,
              xs.hd
            ],
            tl: indexedAux(i + 1 | 0, xs.tl)
          };
  } else {
    return /* [] */0;
  }
}

function indexed(xs) {
  return indexedAux(0, xs);
}

function deleteAt(index, xs) {
  if (index < 0) {
    return xs;
  }
  if (!xs) {
    return /* [] */0;
  }
  var xs$1 = xs.tl;
  if (index === 0) {
    return xs$1;
  } else {
    return {
            hd: xs.hd,
            tl: deleteAt(index - 1 | 0, xs$1)
          };
  }
}

function deleteAtPair(index, xs) {
  if (index < 0) {
    return [
            undefined,
            xs
          ];
  }
  if (!xs) {
    return [
            undefined,
            /* [] */0
          ];
  }
  var xs$1 = xs.tl;
  var x = xs.hd;
  if (index === 0) {
    return [
            Caml_option.some(x),
            xs$1
          ];
  } else {
    return Ley_Tuple$OptolithClient.Bifunctor.second((function (xs) {
                  return {
                          hd: x,
                          tl: xs
                        };
                }), deleteAtPair(index - 1 | 0, xs$1));
  }
}

function setAt(index, e, xs) {
  if (index < 0) {
    return xs;
  }
  if (!xs) {
    return /* [] */0;
  }
  var xs$1 = xs.tl;
  if (index === 0) {
    return {
            hd: e,
            tl: xs$1
          };
  } else {
    return {
            hd: xs.hd,
            tl: setAt(index - 1 | 0, e, xs$1)
          };
  }
}

function modifyAt(index, f, xs) {
  if (index < 0) {
    return xs;
  }
  if (!xs) {
    return /* [] */0;
  }
  var xs$1 = xs.tl;
  var x = xs.hd;
  if (index === 0) {
    return {
            hd: Curry._1(f, x),
            tl: xs$1
          };
  } else {
    return {
            hd: x,
            tl: modifyAt(index - 1 | 0, f, xs$1)
          };
  }
}

function updateAt(index, f, xs) {
  if (index < 0) {
    return xs;
  }
  if (!xs) {
    return /* [] */0;
  }
  var xs$1 = xs.tl;
  var x = xs.hd;
  if (index === 0) {
    return Ley_Option$OptolithClient.option(xs$1, (function (x$prime) {
                  return {
                          hd: x$prime,
                          tl: xs$1
                        };
                }), Curry._1(f, x));
  } else {
    return {
            hd: x,
            tl: updateAt(index - 1 | 0, f, xs$1)
          };
  }
}

function insertAt(index, e, xs) {
  if (index < 0) {
    return xs;
  } else if (xs) {
    if (index === 0) {
      return {
              hd: e,
              tl: xs
            };
    } else {
      return {
              hd: xs.hd,
              tl: insertAt(index - 1 | 0, e, xs.tl)
            };
    }
  } else {
    return /* [] */0;
  }
}

function imapAux(f, i, xs) {
  if (xs) {
    return {
            hd: Curry._2(f, i, xs.hd),
            tl: imapAux(f, i + 1 | 0, xs.tl)
          };
  } else {
    return /* [] */0;
  }
}

function imap(f, xs) {
  return imapAux(f, 0, xs);
}

function ifoldrAux(f, index, acc, xs) {
  if (xs) {
    return Curry._3(f, index, xs.hd, ifoldrAux(f, index + 1 | 0, acc, xs.tl));
  } else {
    return acc;
  }
}

function ifoldr(f, initial, xs) {
  return ifoldrAux(f, 0, initial, xs);
}

function ifoldlAux(f, _index, _acc, _xs) {
  while(true) {
    var xs = _xs;
    var acc = _acc;
    var index = _index;
    if (!xs) {
      return acc;
    }
    _xs = xs.tl;
    _acc = Curry._3(f, acc, index, xs.hd);
    _index = index + 1 | 0;
    continue ;
  };
}

function ifoldl(f, initial, xs) {
  return ifoldlAux(f, 0, initial, xs);
}

function iallAux(f, _index, _xs) {
  while(true) {
    var xs = _xs;
    var index = _index;
    if (!xs) {
      return true;
    }
    if (!Curry._2(f, index, xs.hd)) {
      return false;
    }
    _xs = xs.tl;
    _index = index + 1 | 0;
    continue ;
  };
}

function iall(f, xs) {
  return iallAux(f, 0, xs);
}

function ianyAux(f, _index, _xs) {
  while(true) {
    var xs = _xs;
    var index = _index;
    if (!xs) {
      return false;
    }
    if (Curry._2(f, index, xs.hd)) {
      return true;
    }
    _xs = xs.tl;
    _index = index + 1 | 0;
    continue ;
  };
}

function iany(f, xs) {
  return ianyAux(f, 0, xs);
}

function iconcatMapAux(f, index, xs) {
  if (xs) {
    return Pervasives.$at(Curry._2(f, index, xs.hd), iconcatMapAux(f, index + 1 | 0, xs.tl));
  } else {
    return /* [] */0;
  }
}

function iconcatMap(f, xs) {
  return iconcatMapAux(f, 0, xs);
}

function ifilter(pred, xs) {
  return ifoldr((function (i, x, acc) {
                if (Curry._2(pred, i, x)) {
                  return {
                          hd: x,
                          tl: acc
                        };
                } else {
                  return acc;
                }
              }), /* [] */0, xs);
}

function ipartition(pred, xs) {
  return ifoldr((function (i, x) {
                if (Curry._2(pred, i, x)) {
                  return function (param) {
                    return Ley_Tuple$OptolithClient.Bifunctor.first((function (acc) {
                                  return {
                                          hd: x,
                                          tl: acc
                                        };
                                }), param);
                  };
                } else {
                  return function (param) {
                    return Ley_Tuple$OptolithClient.Bifunctor.second((function (acc) {
                                  return {
                                          hd: x,
                                          tl: acc
                                        };
                                }), param);
                  };
                }
              }), [
              /* [] */0,
              /* [] */0
            ], xs);
}

function ifindAux(pred, _index, _xs) {
  while(true) {
    var xs = _xs;
    var index = _index;
    if (!xs) {
      return ;
    }
    var x = xs.hd;
    if (Curry._2(pred, index, x)) {
      return Caml_option.some(x);
    }
    _xs = xs.tl;
    _index = index + 1 | 0;
    continue ;
  };
}

function ifind(pred, xs) {
  return ifindAux(pred, 0, xs);
}

function ifindIndexAux(pred, _index, _xs) {
  while(true) {
    var xs = _xs;
    var index = _index;
    if (!xs) {
      return ;
    }
    if (Curry._2(pred, index, xs.hd)) {
      return index;
    }
    _xs = xs.tl;
    _index = index + 1 | 0;
    continue ;
  };
}

function ifindIndex(pred, xs) {
  return ifindIndexAux(pred, 0, xs);
}

function ifindIndicesAux(pred, _i, _xs) {
  while(true) {
    var xs = _xs;
    var i = _i;
    if (!xs) {
      return /* [] */0;
    }
    var xs$1 = xs.tl;
    if (Curry._2(pred, i, xs.hd)) {
      return {
              hd: i,
              tl: ifindIndicesAux(pred, i + 1 | 0, xs$1)
            };
    }
    _xs = xs$1;
    _i = i + 1 | 0;
    continue ;
  };
}

function ifindIndices(pred, xs) {
  return ifindIndicesAux(pred, 0, xs);
}

var Index = {
  indexed: indexed,
  deleteAt: deleteAt,
  deleteAtPair: deleteAtPair,
  setAt: setAt,
  modifyAt: modifyAt,
  updateAt: updateAt,
  insertAt: insertAt,
  imapAux: imapAux,
  imap: imap,
  ifoldrAux: ifoldrAux,
  ifoldr: ifoldr,
  ifoldlAux: ifoldlAux,
  ifoldl: ifoldl,
  iallAux: iallAux,
  iall: iall,
  ianyAux: ianyAux,
  iany: iany,
  iconcatMapAux: iconcatMapAux,
  iconcatMap: iconcatMap,
  ifilter: ifilter,
  ipartition: ipartition,
  ifindAux: ifindAux,
  ifind: ifind,
  ifindIndexAux: ifindIndexAux,
  ifindIndex: ifindIndex,
  ifindIndicesAux: ifindIndicesAux,
  ifindIndices: ifindIndices
};

function $less$plus$great(x, xs) {
  return {
          hd: x,
          tl: xs
        };
}

function head(param) {
  if (param) {
    return param.hd;
  } else {
    return Pervasives.invalid_arg("head does only work on non-empty lists. If you do not know whether the list is empty or not, use listToMaybe instead.");
  }
}

function last(_param) {
  while(true) {
    var param = _param;
    if (!param) {
      return Pervasives.invalid_arg("last does only work on non-empty lists.");
    }
    var xs = param.tl;
    if (!xs) {
      return param.hd;
    }
    _param = xs.tl;
    continue ;
  };
}

function tail(param) {
  if (param) {
    return param.tl;
  } else {
    return Pervasives.invalid_arg("tail does only work on non-empty lists.");
  }
}

function init(param) {
  if (!param) {
    return Pervasives.invalid_arg("init does only work on non-empty lists.");
  }
  var xs = param.tl;
  if (xs) {
    return {
            hd: param.hd,
            tl: init(xs)
          };
  } else {
    return /* [] */0;
  }
}

function uncons(param) {
  if (param) {
    return [
            param.hd,
            param.tl
          ];
  }
  
}

function reverse(xs) {
  return Curry._3(foldl$1, (function (param, param$1) {
                return Ley_Function$OptolithClient.flip($less$plus$great, param, param$1);
              }), /* [] */0, xs);
}

function intersperse(sep, xs) {
  if (!xs) {
    return /* [] */0;
  }
  var xs$1 = xs.tl;
  var x = xs.hd;
  if (xs$1) {
    return {
            hd: x,
            tl: {
              hd: sep,
              tl: intersperse(sep, xs$1)
            }
          };
  } else {
    return {
            hd: x,
            tl: /* [] */0
          };
  }
}

function intercalate(separator, xs) {
  if (!xs) {
    return "";
  }
  var xs$1 = xs.tl;
  var x = xs.hd;
  if (xs$1) {
    return intercalate(separator, xs$1) + (separator + x);
  } else {
    return x;
  }
}

function permutationsPick(xs) {
  return imapAux((function (i, x) {
                return [
                        x,
                        deleteAt(i, xs)
                      ];
              }), 0, xs);
}

function permutations(xs) {
  if (xs) {
    if (xs.tl) {
      return Curry._2(concatMap, (function (param) {
                    var x$prime = param[0];
                    return Curry._2(fmap$1, (function (param) {
                                  return {
                                          hd: x$prime,
                                          tl: param
                                        };
                                }), permutations(param[1]));
                  }), permutationsPick(xs));
    } else {
      return {
              hd: {
                hd: xs.hd,
                tl: /* [] */0
              },
              tl: /* [] */0
            };
    }
  } else {
    return /* [] */0;
  }
}

function scanl(f, initial, xs) {
  return {
          hd: initial,
          tl: xs ? scanl(f, Curry._2(f, initial, xs.hd), xs.tl) : /* [] */0
        };
}

function mapAccumL(f, initial, ls) {
  if (!ls) {
    return [
            initial,
            /* [] */0
          ];
  }
  var match = Curry._2(f, initial, ls.hd);
  var match$1 = mapAccumL(f, match[0], ls.tl);
  return [
          match$1[0],
          {
            hd: match[1],
            tl: match$1[1]
          }
        ];
}

function mapAccumR(f, initial, ls) {
  if (!ls) {
    return [
            initial,
            /* [] */0
          ];
  }
  var match = mapAccumR(f, initial, ls.tl);
  var match$1 = Curry._2(f, match[0], ls.hd);
  return [
          match$1[0],
          {
            hd: match$1[1],
            tl: match[1]
          }
        ];
}

function replicate(len, x) {
  if (len > 0) {
    return {
            hd: x,
            tl: replicate(len - 1 | 0, x)
          };
  } else {
    return /* [] */0;
  }
}

function unfoldr(f, seed) {
  var param = Curry._1(f, seed);
  if (param !== undefined) {
    return {
            hd: param[0],
            tl: unfoldr(f, param[1])
          };
  } else {
    return /* [] */0;
  }
}

function take(n, xs) {
  if (n <= 0 || !xs) {
    return /* [] */0;
  } else {
    return {
            hd: xs.hd,
            tl: take(n - 1 | 0, xs.tl)
          };
  }
}

function drop(_n, _xs) {
  while(true) {
    var xs = _xs;
    var n = _n;
    if (n <= 0) {
      return xs;
    }
    if (!xs) {
      return /* [] */0;
    }
    _xs = xs.tl;
    _n = n - 1 | 0;
    continue ;
  };
}

function splitAt(n, xs) {
  if (n <= 0) {
    return [
            /* [] */0,
            xs
          ];
  }
  if (!xs) {
    return [
            /* [] */0,
            xs
          ];
  }
  var match = splitAt(n - 1 | 0, xs.tl);
  return [
          {
            hd: xs.hd,
            tl: match[0]
          },
          match[1]
        ];
}

function isInfixOf(x, y) {
  return x.includes(y);
}

function lookup(k, xs) {
  return Curry._2(Ley_Option$OptolithClient.Infix.$less$amp$great, Curry._2(find, (function (param) {
                    return Caml_obj.caml_equal(k, param[0]);
                  }), xs), (function (prim) {
                return prim[1];
              }));
}

function filter(pred, xs) {
  return Curry._3(foldr$1, (function (x) {
                if (Curry._1(pred, x)) {
                  return function (param) {
                    return {
                            hd: x,
                            tl: param
                          };
                  };
                } else {
                  return Ley_Function$OptolithClient.id;
                }
              }), /* [] */0, xs);
}

function partition(pred, xs) {
  return Curry._3(foldr$1, (function (x) {
                if (Curry._1(pred, x)) {
                  return function (param) {
                    return Ley_Tuple$OptolithClient.Bifunctor.first((function (param) {
                                  return {
                                          hd: x,
                                          tl: param
                                        };
                                }), param);
                  };
                } else {
                  return function (param) {
                    return Ley_Tuple$OptolithClient.Bifunctor.second((function (param) {
                                  return {
                                          hd: x,
                                          tl: param
                                        };
                                }), param);
                  };
                }
              }), [
              /* [] */0,
              /* [] */0
            ], xs);
}

function elemIndex(e, xs) {
  if (xs) {
    if (Caml_obj.caml_equal(e, xs.hd)) {
      return 0;
    } else {
      return Curry._2(Ley_Option$OptolithClient.Infix.$less$$great, Ley_Int$OptolithClient.inc, elemIndex(e, xs.tl));
    }
  }
  
}

function elemIndicesAux(e, _i, _xs) {
  while(true) {
    var xs = _xs;
    var i = _i;
    if (!xs) {
      return /* [] */0;
    }
    var xs$1 = xs.tl;
    if (Caml_obj.caml_equal(e, xs.hd)) {
      return {
              hd: i,
              tl: elemIndicesAux(e, i + 1 | 0, xs$1)
            };
    }
    _xs = xs$1;
    _i = i + 1 | 0;
    continue ;
  };
}

function elemIndices(e, xs) {
  return elemIndicesAux(e, 0, xs);
}

function findIndex(pred, xs) {
  if (xs) {
    if (Curry._1(pred, xs.hd)) {
      return 0;
    } else {
      return Curry._2(Ley_Option$OptolithClient.Infix.$less$$great, Ley_Int$OptolithClient.inc, findIndex(pred, xs.tl));
    }
  }
  
}

function findIndicesAux(pred, _i, _xs) {
  while(true) {
    var xs = _xs;
    var i = _i;
    if (!xs) {
      return /* [] */0;
    }
    var xs$1 = xs.tl;
    if (Curry._1(pred, xs.hd)) {
      return {
              hd: i,
              tl: findIndicesAux(pred, i + 1 | 0, xs$1)
            };
    }
    _xs = xs$1;
    _i = i + 1 | 0;
    continue ;
  };
}

function findIndices(pred, xs) {
  return findIndicesAux(pred, 0, xs);
}

function zip(xs, ys) {
  if (xs && ys) {
    return {
            hd: [
              xs.hd,
              ys.hd
            ],
            tl: zip(xs.tl, ys.tl)
          };
  } else {
    return /* [] */0;
  }
}

function zipWith(f, xs, ys) {
  if (xs && ys) {
    return {
            hd: Curry._2(f, xs.hd, ys.hd),
            tl: zipWith(f, xs.tl, ys.tl)
          };
  } else {
    return /* [] */0;
  }
}

function lines(x) {
  if (x.length === 0) {
    return /* [] */0;
  } else {
    return Ley_Option$OptolithClient.catOptions($$Array.to_list(x.replace(/\n$/u, "").split(/\n/u)));
  }
}

function nub(xs) {
  return Curry._3(foldr$1, (function (x, acc) {
                if (Curry._2(notElem, x, acc)) {
                  return {
                          hd: x,
                          tl: acc
                        };
                } else {
                  return acc;
                }
              }), /* [] */0, xs);
}

function $$delete(e, _xs) {
  while(true) {
    var xs = _xs;
    if (!xs) {
      return /* [] */0;
    }
    var xs$1 = xs.tl;
    if (Caml_obj.caml_equal(e, xs.hd)) {
      return xs$1;
    }
    _xs = xs$1;
    continue ;
  };
}

function $unknown$slash(xs, ys) {
  return filter((function (param) {
                return Ley_Function$OptolithClient.flip(notElem, ys, param);
              }), xs);
}

function intersect(xs, ys) {
  return filter((function (param) {
                return Ley_Function$OptolithClient.flip(elem, ys, param);
              }), xs);
}

function disjoint(xs, _ys) {
  while(true) {
    var ys = _ys;
    if (!xs) {
      return true;
    }
    if (!ys) {
      return true;
    }
    if (!Curry._2(notElem, ys.hd, xs)) {
      return false;
    }
    _ys = ys.tl;
    continue ;
  };
}

function sortBy(f) {
  return function (param) {
    return List.sort((function (a, b) {
                  return Ley_Ord$OptolithClient.fromOrdering(Curry._2(f, a, b));
                }), param);
  };
}

function countBy(f, xs) {
  return Curry._3(foldr$1, (function (x) {
                if (Curry._1(f, x)) {
                  return Ley_Int$OptolithClient.inc;
                } else {
                  return Ley_Function$OptolithClient.id;
                }
              }), 0, xs);
}

function lengthMin(_min, _xs) {
  while(true) {
    var xs = _xs;
    var min = _min;
    if (!xs) {
      return min <= 0;
    }
    _xs = xs.tl;
    _min = min - 1 | 0;
    continue ;
  };
}

function countMinBy(pred, _min, _xs) {
  while(true) {
    var xs = _xs;
    var min = _min;
    if (!xs) {
      return min <= 0;
    }
    if (min <= 0) {
      return true;
    }
    _xs = xs.tl;
    _min = Curry._1(pred, xs.hd) ? min - 1 | 0 : min;
    continue ;
  };
}

function countMin(e) {
  return function (param, param$1) {
    return countMinBy((function (param) {
                  return Caml_obj.caml_equal(e, param);
                }), param, param$1);
  };
}

function lengthMax(_max, _xs) {
  while(true) {
    var xs = _xs;
    var max = _max;
    if (max < 0) {
      return false;
    }
    if (!xs) {
      return true;
    }
    _xs = xs.tl;
    _max = max - 1 | 0;
    continue ;
  };
}

function countMaxBy(pred, _max, _xs) {
  while(true) {
    var xs = _xs;
    var max = _max;
    if (max < 0) {
      return false;
    }
    if (!xs) {
      return true;
    }
    _xs = xs.tl;
    _max = Curry._1(pred, xs.hd) ? max - 1 | 0 : max;
    continue ;
  };
}

function countMax(e) {
  return function (param, param$1) {
    return countMaxBy((function (param) {
                  return Caml_obj.caml_equal(e, param);
                }), param, param$1);
  };
}

function intersecting(xs, ys) {
  return Curry._2(any, (function (x) {
                return Curry._2(elem, x, ys);
              }), xs);
}

var lower = $$String.lowercase_ascii;

function trimStart(str) {
  return str.replace(/^\s+/u, "");
}

function trimEnd(str) {
  return str.replace(/\s+$/u, "");
}

var partial_arg = /[.*+?^${}()|[\]\\]/gu;

function escapeRegex(param) {
  return param.replace(partial_arg, "\\$&");
}

function splitOn(del, x) {
  return $$Array.to_list(x.split(del));
}

function notNull(xs) {
  return !Curry._1($$null, xs);
}

function notNullStr(xs) {
  return 0 < xs.length;
}

function list(def, f, xs) {
  if (xs) {
    return Curry._2(f, xs.hd, xs.tl);
  } else {
    return def;
  }
}

function unsnoc(xs) {
  if (!xs) {
    return ;
  }
  var xs$1 = xs.tl;
  var x = xs.hd;
  if (!xs$1) {
    return [
            /* [] */0,
            x
          ];
  }
  var match = unsnoc(xs$1);
  if (match !== undefined) {
    return [
            {
              hd: x,
              tl: match[0]
            },
            match[1]
          ];
  }
  
}

function snoc(xs, x) {
  if (!xs) {
    return {
            hd: x,
            tl: /* [] */0
          };
  }
  var x$1 = xs.hd;
  return {
          hd: x$1,
          tl: snoc(xs.tl, x$1)
        };
}

function maximumOn(f, xs) {
  return Ley_Tuple$OptolithClient.fst(Curry._3(foldr$1, (function (x, param) {
                    var max = param[1];
                    var res = Curry._1(f, x);
                    if (res > max) {
                      return [
                              Caml_option.some(x),
                              res
                            ];
                    } else {
                      return [
                              param[0],
                              max
                            ];
                    }
                  }), [
                  undefined,
                  Js_int.min
                ], xs));
}

function minimumOn(f, xs) {
  return Ley_Tuple$OptolithClient.fst(Curry._3(foldr$1, (function (x, param) {
                    var min = param[1];
                    var res = Curry._1(f, x);
                    if (res < min) {
                      return [
                              Caml_option.some(x),
                              res
                            ];
                    } else {
                      return [
                              param[0],
                              min
                            ];
                    }
                  }), [
                  undefined,
                  Js_int.max
                ], xs));
}

function firstJust(pred, _xs) {
  while(true) {
    var xs = _xs;
    if (!xs) {
      return ;
    }
    var res = Curry._1(pred, xs.hd);
    if (res !== undefined) {
      return res;
    }
    _xs = xs.tl;
    continue ;
  };
}

function replaceStr(old_subseq, new_subseq, x) {
  return x.replace(new RegExp(Curry._1(escapeRegex, old_subseq), "gu"), new_subseq);
}

function replaceStrRe(old_subseq_rx, new_subseq, x) {
  return x.replace(old_subseq_rx, new_subseq);
}

var Extra = {
  lower: lower,
  trimStart: trimStart,
  trimEnd: trimEnd,
  escapeRegex: escapeRegex,
  splitOn: splitOn,
  notNull: notNull,
  notNullStr: notNullStr,
  list: list,
  unsnoc: unsnoc,
  snoc: snoc,
  maximumOn: maximumOn,
  minimumOn: minimumOn,
  firstJust: firstJust,
  replaceStr: replaceStr,
  replaceStrRe: replaceStrRe
};

function atMay(xs, i) {
  if (i < 0) {
    return ;
  } else {
    return List.nth_opt(xs, i);
  }
}

var Safe = {
  atMay: atMay
};

var include$5 = Ley_Functor$OptolithClient.MakeInfix({
      fmap: fmap$1
    });

function ap$1(fs, xs) {
  if (!fs) {
    return /* [] */0;
  }
  if (!xs) {
    return /* [] */0;
  }
  var x = xs.hd;
  return Pervasives.$at(Curry._2(fmap$1, (function (f) {
                    return Curry._1(f, x);
                  }), fs), ap$1(fs, xs.tl));
}

var include$6 = Ley_Applicative$OptolithClient.MakeInfix({
      fmap: fmap$1,
      pure: pure$1,
      ap: ap$1
    });

function alt$1(xs, ys) {
  if (xs) {
    return xs;
  } else {
    return ys;
  }
}

var include$7 = Ley_Applicative$OptolithClient.Alternative.MakeInfix({
      empty: /* [] */0,
      alt: alt$1
    });

function bind$1(f, xs) {
  if (xs) {
    return Pervasives.$at(Curry._1(f, xs.hd), bind$1(f, xs.tl));
  } else {
    return /* [] */0;
  }
}

var include$8 = Ley_Monad$OptolithClient.MakeInfix({
      pure: pure$1,
      fmap: fmap$1,
      bind: bind$1
    });

var Infix_$less$dollar$great = include$5.$less$$great;

var Infix_$less$amp$great = include$5.$less$amp$great;

var Infix_$less$dollar = include$5.$less$;

var Infix_$$great = include$5.$$great;

var Infix_$less$star$great = include$6.$less$star$great;

var Infix_$less$star$star$great = include$6.$less$star$star$great;

var Infix_$less$pipe$great = include$7.$less$pipe$great;

var Infix_$great$great$eq = include$8.$great$great$eq;

var Infix_$eq$less$less = include$8.$eq$less$less;

var Infix_$great$great = include$8.$great$great;

var Infix_$less$less = include$8.$less$less;

var Infix_$great$eq$great = include$8.$great$eq$great;

var Infix_$less$eq$less = include$8.$less$eq$less;

var Infix = {
  $less$$great: Infix_$less$dollar$great,
  $less$amp$great: Infix_$less$amp$great,
  $less$: Infix_$less$dollar,
  $$great: Infix_$$great,
  $less$star$great: Infix_$less$star$great,
  $less$star$star$great: Infix_$less$star$star$great,
  $less$pipe$great: Infix_$less$pipe$great,
  $great$great$eq: Infix_$great$great$eq,
  $eq$less$less: Infix_$eq$less$less,
  $great$great: Infix_$great$great,
  $less$less: Infix_$less$less,
  $great$eq$great: Infix_$great$eq$great,
  $less$eq$less: Infix_$less$eq$less
};

var liftA2 = include$1.liftA2;

var empty = include$2.empty;

var $$return = include$3.$$return;

var join = include$3.join;

var liftM2 = include$3.liftM2;

var liftM3 = include$3.liftM3;

var liftM4 = include$3.liftM4;

var liftM5 = include$3.liftM5;

var toList = include$4.toList;

var length = include$4.length;

var sum = include$4.sum;

var maximum = include$4.maximum;

var minimum = include$4.minimum;

var concat = include$4.concat;

var con = include$4.con;

var dis = include$4.dis;

var all = include$4.all;

var cons = $less$plus$great;

var $caret = Pervasives.$at;

var append = Pervasives.$at;

var map = fmap$1;

var $bang$bang = List.nth;

var subscript = List.nth;

var listToArray = $$Array.of_list;

var arrayToList = $$Array.to_list;

export {
  fmap$1 as fmap,
  pure$1 as pure,
  liftA2 ,
  empty ,
  $$return ,
  join ,
  liftM2 ,
  liftM3 ,
  liftM4 ,
  liftM5 ,
  foldr$1 as foldr,
  foldl$1 as foldl,
  toList ,
  $$null ,
  length ,
  sum ,
  maximum ,
  minimum ,
  concat ,
  concatMap ,
  con ,
  dis ,
  any ,
  all ,
  find ,
  Index ,
  $less$plus$great ,
  cons ,
  $caret ,
  append ,
  head ,
  last ,
  tail ,
  init ,
  uncons ,
  map ,
  reverse ,
  intersperse ,
  intercalate ,
  permutations ,
  scanl ,
  mapAccumL ,
  mapAccumR ,
  replicate ,
  unfoldr ,
  take ,
  drop ,
  splitAt ,
  isInfixOf ,
  elem ,
  notElem ,
  lookup ,
  filter ,
  partition ,
  $bang$bang ,
  subscript ,
  elemIndex ,
  elemIndicesAux ,
  elemIndices ,
  findIndex ,
  findIndicesAux ,
  findIndices ,
  zip ,
  zipWith ,
  lines ,
  nub ,
  $$delete ,
  $unknown$slash ,
  intersect ,
  disjoint ,
  sortBy ,
  countBy ,
  lengthMin ,
  countMinBy ,
  countMin ,
  lengthMax ,
  countMaxBy ,
  countMax ,
  intersecting ,
  listToArray ,
  arrayToList ,
  Extra ,
  Safe ,
  Infix ,
  
}
/* include Not a pure module */
