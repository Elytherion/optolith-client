// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE

import * as Json_decode from "@glennsl/bs-json/src/Json_decode.bs.js";
import * as Curry from "bs-platform/lib/es6/curry.js";
import * as Js_math from "bs-platform/lib/es6/js_math.js";
import * as Ley_Int$OptolithClient from "../Data/Ley_Int.bs.js";

function rollDie(sides) {
  return Ley_Int$OptolithClient.inc(Js_math.floor(Math.random() * sides));
}

function $neg$pipe(a, b) {
  if (a >= 0) {
    return a - b | 0;
  } else {
    return a + b | 0;
  }
}

function rollDiceAux(amount, sides) {
  if (Ley_Int$OptolithClient.abs(amount) <= 1) {
    return {
            hd: rollDie(sides),
            tl: /* [] */0
          };
  } else {
    return {
            hd: rollDie(sides),
            tl: rollDiceAux($neg$pipe(amount, 1), sides)
          };
  }
}

function rollDice(param) {
  return rollDiceAux(param.amount, param.sides);
}

function rollDiceSumAux(amount, sides) {
  if (Ley_Int$OptolithClient.abs(amount) <= 1) {
    return rollDie(sides);
  } else {
    return rollDie(sides) + rollDiceSumAux($neg$pipe(amount, 1), sides) | 0;
  }
}

function rollDiceSum(param) {
  return rollDiceSumAux(param.amount, param.sides);
}

function rollDiceSumMapAux(map, amount, sides) {
  if (Ley_Int$OptolithClient.abs(amount) <= 1) {
    return Curry._2(map, {
                amount: amount,
                sides: sides
              }, rollDie(sides));
  } else {
    return Curry._2(map, {
                amount: amount,
                sides: sides
              }, rollDie(sides)) + rollDiceSumMapAux(map, $neg$pipe(amount, 1), sides) | 0;
  }
}

function rollDiceSumMap(f, param) {
  return rollDiceSumMapAux(f, param.amount, param.sides);
}

function t(json) {
  return {
          amount: Json_decode.field("amount", Json_decode.$$int, json),
          sides: Json_decode.field("sides", Json_decode.$$int, json)
        };
}

var Decode = {
  t: t
};

export {
    rollDice,
    rollDiceSum,
    rollDiceSumMap,
    Decode,

};
/* No side effect */
